#### 谈谈Vue的优缺点？

Vue是一个单页面应用（什么是单页面），将所有的资源和单页面集成于一个页面上。这些文件在应用开始访问时就一起加载完，根据系统的不同功能通过加载不同功能组件的形式来切换不同功能组件。所以整个系统在切换不同功能时，页面的地址是不变的系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验。

它的优点是：依靠路由分发直接在浏览器端完成，页面是不刷新，对用户的响应非常及时，提升了用户体验；前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；可以在多端共享组件，便于产品的快速迭代，节约资源，其次它是一个构建数据驱动的 web 界面的渐进式框架，开发者不必关心DOM操作，通过Vue自带的一些指令和事件修饰符，直接把数据或者事件绑定到相应的节点上即可。开发者只需要关心工作的业务和数据以及视图即可。

它的缺点是：由于最终将所有单页面集成于一个页面上首次加载大量资源等待耗时，不利于SEO网络优化，因为SEO搜索引擎认识HTML中的内容，不认识js中的内容。由于单页面中的内容都是靠js渲染生成的，所以搜索引擎不识别这块 的内容，就不会给网页一个好的排名。

#### 什么是fs模块？

fs是node.js的一个文件系统模块，该模块提供本地文件的读写能力。例如：

(```)

```
fs.readFile('文件.txt', 'utf8', (err, data) => { 
  if (err) {
    throw err; console.log('文件已被保存');
  }else{
      console.log(data);
  }
})//写入数据到该本地文件中

var fs = require('fs')
fs.writeFile('文件.txt', 'utf8', (err, data) => { 
  if (err) {
    throw err; console.log('文件已被保存');
  }else{
      console.log(data);
  }
})//写入数据到该本地文件中
```

(```)

####  什么是path模块？

path模块也是node.js的一个API，它是连接文件路径模块，path.dirname()该模块方法返回 `path` 的目录名；

```
console.log(__dirname + '/example.db');例如输出如下:
/Users/durban/nodejs/koa-mysql-orm-model/example.db
```

#### 什么是BFC？

BFC ( block flow content )块级格式化上下文;

那么什么是块级格式化上下文呢？与其说我们何不尝来创建一个这样的场景来说明，这样更具有说服力。

(```)

<style>

​    main{

​        width: 500px;

​        background-color: red;

​        /* overflow: auto; */

​        /* overflow：不为unset、inherit、visible */

​    }

​    div{

​        width: 200px;

​        height: 200px;      

​    }

​    .first{

​        background-color: #000; 

​        float: left;

​    }

​    .second{

​        background-color: yellowgreen;

​        float: left; 

​    }

​    </style>

<body>

​    <main>

​        <div class="first"></div>

​        <div class="second"></div>

​    </main>

</body>

(```)

![pic_1](D:\Interview-Tips\images\pic_1.png)

我们创建了一个父盒子的宽位500px，与此同时内嵌了两个宽高各为200px的子盒子并且都做左浮动，如上图所示。当我们审查父盒子时，父盒子已随着子盒子的浮动脱其父盒子的文档流，导致父盒子没有被撑起来而造成父盒子的塌陷，其原因就是浮动元素并 “没有参与父盒子的计算”。这个时候我们就要给父盒子创建一个BFC环境，让浮动元素也参与父盒子的计算。如下图所示：



![pic_2](D:\Interview-Tips\images\pic_2.png)

OK，那么如果面试官问到你什么是BFC时该如何表述呢？网上的解释五花八门的，有面试官提解出让你解决margin叠加问题，清除内部浮动问题etc。其实就是让你创建一个BFC环境来解决此问题。

如何创建一个BFC？上述我们已经提出了一个就是overflow的值不为unset、inherit、visible。其次还有float属性不为none；position为absolute或fixed；display属性值为inline-block 或者flex等。有的面试官还会问：假设父盒子内嵌两个子盒子，第一个子盒子的margin-bottom为10px;第二个子盒子的    margin-top为20px，那么连个子盒子相距为多少？千万不能回答30px。要回答两则之间取margin最大值20px,相距为20px即可。

#### 什么是盒子模型？

一个盒子模型是由margin、border、padding、content构成。不同的是IE的内容区包含了border、padding。

#### box-sizing属性有哪两个值？

content-box和border-box。box-sizing属性默认值为content-box，并且border和padding不参与width和height的计算。

#### Vue computed、methods和watch的区别?

如果计算属性的用来做一些计算使用的，比如增删改查，购物车商品添加和删除以及搜索等，

它监听原来的数据没有变化是不会执行set方法，而是使用缓存的值。

而watch用来做一些更复杂的异步处理，比如依赖的值发生变化做余下部分的业务处理。

比如跳转，调用api方法等。如果用watch来做计算属性的事，开销过大且复杂。

methods则用来做一些事件绑定处理，当触发该绑定的事件才会执行，

虽然watch和methods都可以实现computed的所做的，但是其开销过大，所谓开销过大就是每次调用两者时都会执行

该方法对整个过程重新处理，计算属性之所以开销不大如前述所言它是利用Object.defineProperty

监听属性的值没有变化如果原来的值没有被修改是不会执行set方法，而是使用上一次缓存的值。

#### 谈谈JavaScript事件机制

事件机制分为事件冒泡，事件捕获以及事件循环；

##### 事件冒泡，事件捕获:

##### 在JavaScript中把标准事件模型的执行分为三个阶段，即捕获阶段->目标阶段->冒泡阶段。

事件模型：DOM有DOM模型，那么JS事件也有JS事件模型，事件模型是指在DOM树层级的结构中绑定着同一个事件方法，这个称之为事件模型。

事件流：当触发这个事件模型中的某个事件时，此时会产生一个事件流。在事件流中又分为两种事件流，一种是事件冒泡，一种是事件捕获。

在事件的传播过程中，事件先沿着document节点，一层一层的向下传播，直到遇到注册事件的目标节点，这个过程称之为捕获阶段。

元素注册的事件函数开始运行，运行完毕则由沿着DOM树向上层传播，回到document节点则事件结束，这个过程称之为事件冒泡。

在IE8之前的事件机制没有捕获阶段，只有目标阶段和冒泡阶段。

谈谈JavaScript事件机制分为事件冒泡，

事件捕获以及事件循环

事件冒泡和事件捕获恰恰相反，


事件注册分为三种，一种是dom0级事件，这种方式是直接把事件绑定在元素的标签中；


一种是dom2级事件，这种方式是通过获取元素把事件绑定在改节点对象中；

另一种是通过事件监听dom，el.addEventListener()和attachEvent()


el.addEventListener()第一参数是事件的类型，第二个参数是事件的函数，第三个参数是一个布尔值，是否捕获，

默认为true在捕获阶段，false为冒泡阶段。


attachEvent("on"+type,fn)仅有两个参数，第一个参数是事件的类型，第二个则是事件的函数。

在标准事件监听中移除事件监听使用el.removeEventListener()第一参数是事件的类型，

第二个参数是事件的函数。 

IE8之前则使用target.detachEvent("on"+type,fn)；

##### 事件循环：

说说事件循环就不得不从js是一门单线程开始说起了。

单线程意味着，js代码在执行的任何时候，都只有一个主线程来处理所有的任务。

所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

为了避免阻塞线程，于是线程上的任务又分为同步任务和异步任务。那么什么是同步和异步呢？

同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；

异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任

务才会进入主线程执行。


所有同步任务都在主线程上执行，形成一个执行栈,

除此之外主线程，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

当执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任。

主线程不断重复这个过程就称之为事件循环。

那么什么是任务队列？

"任务队列"是一个事件的队列（也可以理解成消息的队列）；


heap(堆)和stack(栈)

1.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。

2.stack空间有限，heap的空间是很大的自由区。

浏览器的 Event Loop 遵循的是 HTML5 标准，而 NodeJs 的 Event Loop 遵循的是 libuv。

#### JS异步原理

如果要理解异步原理则先了解js的事件循环机制即可；

#### 普通函数与箭头函数的区别

箭头函数不存在严格模式，普通函数在处于严格模式情况下this指向undefined,非严格模式下this模式指向window；

箭头函数不能作为构造函数；

箭头函数不绑定arguments，取而代之用rest参数；

普通函数的this则指向事件调用发生的对象，箭头函数的this永远指向其上下文的this，

任何方法都改变不了其指向，如call(), bind(), apply()。

箭头函数没有原型属性。

#### var、let 、const三者之间的区别

1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
2. let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
3. const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。

#### 什么是闭包？它的应用场景和优缺点

##### 闭包的概念：

它的权限是该函数内部的函数有权读写该函数作用域的变量。该函数内部的函数引用着该函数作用域的变量，并且将该函数内部的函数作为该函数的一个返回值返回出去；

闭包之所以会有缓存？原因是在内部函数引用着其它作用域的变量，这些变量不会被释放，如

果释放闭包，给被引用的变量赋值为null，这既是闭包的优点亦是闭包的缺点。它的优点就是可以创建一个封闭的私有作用域避免全局污染，它的缺点就是使用不当当缓存超出其本身的最大上限就会发生栈溢出。

##### 闭包的原理：

在函数执行期，子函数有权访问读写父函数内部的变量；

闭包利用了作用域和作用域链

作用域：作用域是指一个变量的作用范围；作用域分为局部作用域和全局作用域，一个变量的作用范围要么作用于局部作用域要么作用于全

局作用域，局部变量只作用于函数内,只能在当前作用域进行访问。局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。

全局变量作用于全局作用域，在全局范围内都是可以访问的。

作用域链：是指，在函数执行时，函数内部引用函数外部变量之间所产生的一种关系链。并且根据这个关系，该函数内部有权访问函数外部的变量。

#### 移动端如何做终端适配

#### 前端如何预防xss攻击

#### 如何避免爬虫

#### XHTML与HTML二者有什么区别

1.所有的标记都必须要有一个相应的结束标记
2.所有标签的元素和属性的名字都必须使用小写
3.所有的XML标记都必须合理嵌套
4.所有的属性必须用引号""括起来
5.把所有<和&特殊符号用编码表示
6.给所有属性赋一个值
7.不要在注释内容中使“–”
8.图片必须有说明文字

#### 常见兼容性问题

#### html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？

添加节点：

//创建元素节点
var p=document.createElement("p");

//创建文本节点
var text=document.createTextNode("文本。");
p.appendChild(text);//向p节点添加文本内容

var div=document.getElementById("div1");
//向一个已有的div元素追加已有内容的p节点
div.appendChild(p);
//通过标签名称
document.getElementsByTagName("")    
//通过元素的Name属性的值
document.getElementsByName("")    
//通过元素Id，唯一性
document.getElementById("")    
//通过类查找
document.getElementsByClassName(""); 

document.querySelector("")

document.querySelectorAll("")

appendChild()

removeChild(el)

replaceChild(newnode,oldnode)

insertBefore(newnode,指定插入的目标节点)

insertAfter()

el.cloneNode(true)//如果为true就是深克隆节点，将会克隆当然元素的子节点也克隆

#### 如何实现浏览器内多个标签页之间的通信?

```
调用localstorge、cookies等本地存储方式
```

#### 线程与进程的区别

#### 如何对网站的文件和资源进行优化？

#### `async`与`defer`区别























