js封装一个方法为什么要使用函数来封装?

因为通过函数来封装主要是为了能够创建一个私有作用域，

在该函数内部所有的活动对象都不会被外界所干扰，复用性比较好。

那为什么在采用函数封装，函数内部都必须对象的方式呢?

我们知道，使用函数封装如果不采用对象的方式来定义函数封装，

那么我们是没法获取函数内部定义的活动对象。

为什么这么说没法获取函数内部定义的活动对象呢?

我们知道如果获取函数内部的变量或者对象或者方法都必要要把该变量或者该对象该方法return给

外部的函数，作为外部函数的一个返回值才能拿到。

如果使用函数封装函数内部的活动对象(变量、对象、方法)不采用对象的方式我到底拿哪一个呢?

return哪一个呢?

所以我们在使用函数封装的时候采用对象封装是最好的选择，然后把该对象作为函数的一个返回值即可，

当使用的时候调用该函数通过点(.)的方式就能获取到函数内部的对象的属性。

我们来还原一下代码如下

// 工厂模式
function sum() {
   var obj = {
       name: '张三',
       fn: function () {
            console.log(this.name)
           }
       }
   return obj;
   // 或者这样写
   // return {
   //     name: '张三',
   //     fn: function () {
   //         console.log(this.name)
   //     }
   // }
}
console.log(sum()) // {name: "张三", fn: ƒ}

我们从上述代码发现，这其实就是函数内部弄了一个对象，

不同的是作用域，这个函数内部的对象已经不是全局作用域的对象,

而是属于sum这个函数作用域的对象，其实使用函数封装就是创建一个私有作用域，

访问的时候直接调用该函数即可。

还有一种函数方式封装就是构造函数，采用构造函数封装与上述方式不同的是没有return，

而不是在函数内直接把对象return出去作为函数的一个返回值。

使用构造函数就是构建一个对象不是和上述那样弄个return。

构造函数是把函数自己本身作为一个对象的同时又作为函数，

采用到了既能封装函数内部的活动对象，又能够创建一个私有作用域。

既然构造函数就是把函数自己本身作为一个对象，那么肯定函数首字母要大写，

还必须要有new,那么什么是new呢? 它是干嘛的? new其实本身就是一个用来构建对象的关键字，

当我们使用new关键字就会开辟一个内存创建一个对象，如果我们使用构造函数，那么构造函数

内部的this就会指向该new 出来这个构造函数对象的内存。我们来看一下如下代码:

        function Action() {
            this.food = '鱼';
            this.eat = function () {
                console.log(this.food)
            };
        }
        var action = new Action()
        console.log(action) // {food: "鱼", eat: ƒ}