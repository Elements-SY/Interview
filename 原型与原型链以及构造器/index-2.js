function Puppy () {
  this.name = '咪咪';
  this.run = function () {

  }
}
Puppy.prototype.eat = function () {

}
var puppy = new Puppy()
console.log(Puppy.prototype) // prototype属性(原型)属于构造函数的一个属性 指向构造函数构造出来的实例化对象
console.log(puppy.__proto__) // __proto__属性(原型链)是属于实例化对象的一个属性 指向构造函数构造出来的实例化对象
console.log(puppy.constructor) // 构造函数的引用地址

  //         constructor与__proto__的区别：
  // 它们之间的区别在于constructor指的是构造函数的引用地址，是指由哪个构造函数对象够构成的,
  // 与通过__proto__不同的是由哪个构造函数对象构成的,记住它们俩的区别，
  // 一个是由哪个函数构成的(函数的地址)，一个是由哪个构造函数对象构成的(内存)。


  //         原型与原型链的区别以及为什么要有原型链的存在：
  // 原型属性属于构造函数的一个属性 指向构造函数构造出来的实例化对象
  // 原型链属性是属于实例化对象的一个属性 指向构造函数构造出来的实例化对象
  // 我们知道对象有构造对象，有实例化对象，它们之间的关系是，实例化对象是由构造函数构造出来的对象，
  // 那么为了寻找这个实例化是由谁哪个构造函数构造出来的，就必须要通过原型链来寻找那个构造它的构造函数。
  // 我们知道，当使用函数构造一个实例化对象时，你作为一个变量保存起来，你名字可以随便定义，
  // 但是我知道这个实例化对象是由一个构造函数构造出来的，但是我怎么知道你是哪个构造函数构造出来的对象呢？是吧？
  // 所以这个时候原型链就能派上用场了，通过它能帮我们找到该实例化对象是由哪个构造函数构造出来的对象。



  // 构造函数构造出来的实例化对象的构造器属性与构造函数方法的关系
  // 所有由构造函数构造出来的实例化对象的属性和方法都挂载到该构造对象当中。
  // 而所有由构造函数构造出来的实例化对象的原型属性和原型方法都挂载到该构造对象的原型当中。

  // 构造函数的原型与构造函数对象
  // 而所有构造函数的原型都会被挂载到 构造器对象中，并不是挂载到构造器对象的构造属性当中
  // 一个构造函数的prototype属性(原型)永远指向该构造函数的构造对象。
  // 但是一个构造函数的__proto__属性(原型链)永远指向Object构造函数的构造对象或者说顶级原型
  // 顶级的原型链为空(null)

// ``````````````````````````````````````````````````````````````````````````````````````````

// 如何理解一个构造函数的prototype属性(原型)永远指向该构造函数的构造对象呢？

// 我们new Puppy()一个构造函数，那么它的prototype属性是不是指向它Puppy构造函数？
// 它构造一个对象时，是不是有原型和原型链，实例化对象虽然不是构造函数它是不是也有原型和原型链？
// 只不过实例化对象不能通过原型属性直接找够造它(实例化对象)的原型而已，需要通过原型链(__proto__)属性来找而已。
// 当我们通过原型链或者原型属性找到它时，它构造器属性里的prototype属性是不是还是指向它自己本身？
// 这就是说为什么一个构造函数的prototype属性(原型)永远指向该构造函数的构造对象。